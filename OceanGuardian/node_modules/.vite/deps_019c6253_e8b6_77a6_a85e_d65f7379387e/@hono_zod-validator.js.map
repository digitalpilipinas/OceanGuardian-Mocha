{
  "version": 3,
  "sources": ["../../hono/dist/utils/buffer.js", "../../hono/dist/validator/validator.js", "../../@hono/zod-validator/src/index.ts"],
  "sourcesContent": ["// src/utils/buffer.ts\nimport { sha256 } from \"./crypto.js\";\nvar equal = (a, b) => {\n  if (a === b) {\n    return true;\n  }\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  const va = new DataView(a);\n  const vb = new DataView(b);\n  let i = va.byteLength;\n  while (i--) {\n    if (va.getUint8(i) !== vb.getUint8(i)) {\n      return false;\n    }\n  }\n  return true;\n};\nvar timingSafeEqual = async (a, b, hashFunction) => {\n  if (!hashFunction) {\n    hashFunction = sha256;\n  }\n  const [sa, sb] = await Promise.all([hashFunction(a), hashFunction(b)]);\n  if (!sa || !sb) {\n    return false;\n  }\n  return sa === sb && a === b;\n};\nvar bufferToString = (buffer) => {\n  if (buffer instanceof ArrayBuffer) {\n    const enc = new TextDecoder(\"utf-8\");\n    return enc.decode(buffer);\n  }\n  return buffer;\n};\nvar bufferToFormData = (arrayBuffer, contentType) => {\n  const response = new Response(arrayBuffer, {\n    headers: {\n      \"Content-Type\": contentType\n    }\n  });\n  return response.formData();\n};\nexport {\n  bufferToFormData,\n  bufferToString,\n  equal,\n  timingSafeEqual\n};\n", "// src/validator/validator.ts\nimport { getCookie } from \"../helper/cookie/index.js\";\nimport { HTTPException } from \"../http-exception.js\";\nimport { bufferToFormData } from \"../utils/buffer.js\";\nvar jsonRegex = /^application\\/([a-z-\\.]+\\+)?json(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\nvar multipartRegex = /^multipart\\/form-data(;\\s?boundary=[a-zA-Z0-9'\"()+_,\\-./:=?]+)?$/;\nvar urlencodedRegex = /^application\\/x-www-form-urlencoded(;\\s*[a-zA-Z0-9\\-]+\\=([^;]+))*$/;\nvar validator = (target, validationFunc) => {\n  return async (c, next) => {\n    let value = {};\n    const contentType = c.req.header(\"Content-Type\");\n    switch (target) {\n      case \"json\":\n        if (!contentType || !jsonRegex.test(contentType)) {\n          break;\n        }\n        try {\n          value = await c.req.json();\n        } catch {\n          const message = \"Malformed JSON in request body\";\n          throw new HTTPException(400, { message });\n        }\n        break;\n      case \"form\": {\n        if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {\n          break;\n        }\n        let formData;\n        if (c.req.bodyCache.formData) {\n          formData = await c.req.bodyCache.formData;\n        } else {\n          try {\n            const arrayBuffer = await c.req.arrayBuffer();\n            formData = await bufferToFormData(arrayBuffer, contentType);\n            c.req.bodyCache.formData = formData;\n          } catch (e) {\n            let message = \"Malformed FormData request.\";\n            message += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;\n            throw new HTTPException(400, { message });\n          }\n        }\n        const form = {};\n        formData.forEach((value2, key) => {\n          if (key.endsWith(\"[]\")) {\n            ;\n            (form[key] ??= []).push(value2);\n          } else if (Array.isArray(form[key])) {\n            ;\n            form[key].push(value2);\n          } else if (key in form) {\n            form[key] = [form[key], value2];\n          } else {\n            form[key] = value2;\n          }\n        });\n        value = form;\n        break;\n      }\n      case \"query\":\n        value = Object.fromEntries(\n          Object.entries(c.req.queries()).map(([k, v]) => {\n            return v.length === 1 ? [k, v[0]] : [k, v];\n          })\n        );\n        break;\n      case \"param\":\n        value = c.req.param();\n        break;\n      case \"header\":\n        value = c.req.header();\n        break;\n      case \"cookie\":\n        value = getCookie(c);\n        break;\n    }\n    const res = await validationFunc(value, c);\n    if (res instanceof Response) {\n      return res;\n    }\n    c.req.addValidatedData(target, res);\n    await next();\n  };\n};\nexport {\n  validator\n};\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { Context, Env, Input, MiddlewareHandler, TypedResponse, ValidationTargets } from 'hono'\nimport { validator } from 'hono/validator'\nimport type * as v3 from 'zod/v3'\nimport type { ZodSafeParseResult as v4ZodSafeParseResult } from 'zod/v4'\nimport type * as v4 from 'zod/v4/core'\nimport type { InferInput } from './utils'\n\ntype ZodSchema = v3.ZodType | v4.$ZodType\ntype ZodError<T extends ZodSchema> = T extends v4.$ZodType\n  ? v4.$ZodError<v4.output<T>>\n  : v3.ZodError\ntype ZodSafeParseResult<T, T2, T3 extends ZodSchema> = T3 extends v4.$ZodType\n  ? v4ZodSafeParseResult<T>\n  : v3.SafeParseReturnType<T, T2>\ntype zInput<T> = T extends v3.ZodType ? v3.input<T> : T extends v4.$ZodType ? v4.input<T> : never\ntype zOutput<T> = T extends v3.ZodType ? v3.output<T> : T extends v4.$ZodType ? v4.output<T> : never\ntype zInfer<T> = T extends v3.ZodType ? v3.infer<T> : T extends v4.$ZodType ? v4.infer<T> : never\n\nexport type Hook<\n  T,\n  E extends Env,\n  P extends string,\n  Target extends keyof ValidationTargets = keyof ValidationTargets,\n  O = {},\n  Schema extends ZodSchema = any,\n> = (\n  result: ({ success: true; data: T } | { success: false; error: ZodError<Schema>; data: T }) & {\n    target: Target\n  },\n  c: Context<E, P>\n) => Response | void | TypedResponse<O> | Promise<Response | void | TypedResponse<O>>\n\ntype HasUndefined<T> = undefined extends T ? true : false\n\ntype ExtractValidationResponse<VF> = VF extends (value: any, c: any) => infer R\n  ? R extends Promise<infer PR>\n    ? PR extends TypedResponse<infer T, infer S, infer F>\n      ? TypedResponse<T, S, F>\n      : PR extends Response\n        ? PR\n        : PR extends undefined\n          ? never\n          : never\n    : R extends TypedResponse<infer T, infer S, infer F>\n      ? TypedResponse<T, S, F>\n      : R extends Response\n        ? R\n        : R extends undefined\n          ? never\n          : never\n  : never\n\ntype DefaultInput<Target extends keyof ValidationTargets, In, Out> = {\n  in: HasUndefined<In> extends true\n    ? {\n        [K in Target]?: [In] extends [ValidationTargets[K]] ? In : InferInput<In, K>\n      }\n    : {\n        [K in Target]: [In] extends [ValidationTargets[K]] ? In : InferInput<In, K>\n      }\n  out: { [K in Target]: Out }\n}\n\n// without hook and options\nfunction zValidatorFunction<\n  T extends ZodSchema,\n  Target extends keyof ValidationTargets,\n  E extends Env,\n  P extends string,\n  In = zInput<T>,\n  Out = zOutput<T>,\n  I extends Input = DefaultInput<Target, In, Out>,\n  V extends I = I,\n>(target: Target, schema: T): MiddlewareHandler<E, P, V>\n\n// with hook and options\nfunction zValidatorFunction<\n  T extends ZodSchema,\n  Target extends keyof ValidationTargets,\n  E extends Env,\n  P extends string,\n  HookFn extends Hook<InferredValue, E, P, Target, {}, T>,\n  In = zInput<T>,\n  Out = zOutput<T>,\n  I extends Input = DefaultInput<Target, In, Out>,\n  V extends I = I,\n  InferredValue = zInfer<T>,\n>(\n  target: Target,\n  schema: T,\n  hook?: HookFn,\n  options?: {\n    validationFunction: (\n      schema: T,\n      value: ValidationTargets[Target]\n    ) => ZodSafeParseResult<any, any, T> | Promise<ZodSafeParseResult<any, any, T>>\n  }\n): MiddlewareHandler<E, P, V, ExtractValidationResponse<HookFn>>\n\n// implementation\nfunction zValidatorFunction<\n  T extends ZodSchema,\n  Target extends keyof ValidationTargets,\n  E extends Env,\n  P extends string,\n  HookFn extends Hook<InferredValue, E, P, Target, {}, T>,\n  In = zInput<T>,\n  Out = zOutput<T>,\n  I extends Input = DefaultInput<Target, In, Out>,\n  V extends I = I,\n  InferredValue = zInfer<T>,\n>(\n  target: Target,\n  schema: T,\n  hook?: HookFn,\n  options?: {\n    validationFunction: (\n      schema: T,\n      value: ValidationTargets[Target]\n    ) => ZodSafeParseResult<any, any, T> | Promise<ZodSafeParseResult<any, any, T>>\n  }\n): MiddlewareHandler<E, P, V> | MiddlewareHandler<E, P, V, ExtractValidationResponse<HookFn>> {\n  // @ts-expect-error not typed well\n  return validator(target, async (value: ValidationTargets[Target], c) => {\n    let validatorValue = value\n\n    // in case where our `target` === `header`, Hono parses all of the headers into lowercase.\n    // this might not match the Zod schema, so we want to make sure that we account for that when parsing the schema.\n    if ((target === 'header' && '_def' in schema) || (target === 'header' && '_zod' in schema)) {\n      // create an object that maps lowercase schema keys to lowercase\n      // @ts-expect-error the schema is a Zod Schema\n      const schemaKeys = Object.keys('in' in schema ? schema.in.shape : schema.shape)\n      const caseInsensitiveKeymap = Object.fromEntries(\n        schemaKeys.map((key) => [key.toLowerCase(), key])\n      )\n\n      validatorValue = Object.fromEntries(\n        Object.entries(value).map(([key, value]) => [caseInsensitiveKeymap[key] || key, value])\n      )\n    }\n\n    const result =\n      options && options.validationFunction\n        ? await options.validationFunction(schema, validatorValue)\n        : // @ts-expect-error z4.$ZodType has safeParseAsync\n          await schema.safeParseAsync(validatorValue)\n\n    if (hook) {\n      const hookResult = await hook({ data: validatorValue, ...result, target }, c)\n      if (hookResult) {\n        if (hookResult instanceof Response) {\n          return hookResult\n        }\n\n        if ('response' in hookResult) {\n          return hookResult.response\n        }\n      }\n    }\n\n    if (!result.success) {\n      return c.json(result, 400)\n    }\n\n    return result.data as zInfer<T>\n  })\n}\n\nexport const zValidator: typeof zValidatorFunction = zValidatorFunction\n"],
  "mappings": "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",
  "names": ["value", "zValidator: typeof zValidatorFunction"]
}
